# Лекция 4. Auto. Последовательные контейнеры. (21.01.2022)

## Ключевое слово auto

auto - ключевое слово, которое говорит, что нужно определить тип переменной при компиляции


```python
auto number = 1; // int
```

Можно сделать auto ссылки:


```python
auto& number2 = number_ref
const auto& number2 = number_ref
```

Плюсы auto:
- auto позволяет написать код, который будет работать, даже если какие-то типы поменяются
- сокращение очень длинных типов
- хорошо применяется в шаблонных классах и функциях

Минусы auto:
- auto делает код менее понятным

## Массивы

Массив - последовательная область памяти.

Массивы используются для:
- низкоуровневой работы с памятью
- контейнеры стандартной бибилиотеки

Инициализация массива:


```python
int numbers[5] = {0};               // [0, 0, 0, 0, 0]. Работает только для 0!
int numbers[5] = {1, 2, 3, 4, 5};   // [1, 2, 3, 4, 5]
int numbers[5] = {1};               // [1, 0, 0, 0, 0]
int[5] numbers = {0};               // ОШИБКА
```

Массив всегда передается в функцию как указатель на его начало.

Массивы используются редко.

## Строки

Нужно подключать библиотеку string.

- хранит внутри некоторую область памяти
- строки можно сравнивать через знаки равно
- строки можно складывать через +
- есть метод append 
- можно искать вхождение другой строки str1.find(“abcd”)
- преобразовать число в строку: std::to_string

## Vector

Вектор - список, который хранится последовательно в памяти.

Для работы с векторами подключается библиотека vector.

Внутри <> пишется тип элемента вектора:


```python
std::vector<int> = {1, 2, 3};
```

Итератор - объект, который указывает на элемент коллекции.
- begin -  указывает на первый элемент
- end  - указывает на следующий элемент после последнего заполненного
- rbegin - указывает на последний элемент
- rend - указывает на элемент перед нулевым 

Пройтись по всем элементам вектора (range-based for):


```python
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (const auto& n : numbers) {
    std::cout << n << std::endl;            
}
```

## Array

- похож на вектор, но имеет фиксированный размер
- вообще не нужен


```python
#include <array>
std::array<int, 5> numbers = {1, 2, 3, 4, 5};
std::array<int, 5> numbers2 = {1, 2, 3};       // эквивалентно [1, 2, 3, 0, 0]
```

## Std::list

Реализация двусвязного списка. 

- в отличие от std::vector нельзя получить любой элемент за O(1)
- позволяет дешево вставлять элементы в любое место за O(1)

## Std::forward_list

- у итератора нет --
- нет методов rbegin, rend

## Std::deque

- есть доступ по индексу
- эффективная вставка в любое место
